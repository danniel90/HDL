%decls %{
#include <cstdlib>
#include <string>
#include <vector>
#include <map>
#include <math.h>

#include <boost/dynamic_bitset.hpp>

using namespace std;

class vectorExpr;
class vectorId;

class vectorBool;
class TruthTableElem;
class TruthTable;

class vectorMetaType;
class mapTipo;

class BitSet;
class mapBitSet;
class mapFuncion;

extern mapTipo *TablaTipos;
extern mapBitSet *TablaValores;
extern mapFuncion *TablaFunciones;

%}

%decls %end %{

class BitSet{
public:
	boost::dynamic_bitset<> *pbitset;
	BitSet(int s, long val) { pbitset = new boost::dynamic_bitset<>(s, val); }
	BitSet(boost::dynamic_bitset<> *pbs) { pbitset = pbs; }
	BitSet() { }
	~BitSet() { delete pbitset; }
};

class vectorId
{
public:
	vector<string> *ids;
	
	vectorId() { ids = new vector<string>(); }
	~vectorId() { delete ids; }
};

class vectorExpr
{
public:
	vector<Expr*> *exprs;
	
	vectorExpr(){ exprs = new vector<Expr*>(); }
	~vectorExpr() { delete exprs; }
};


class vectorBool
{
public:
	vector<bool> *bools;
	vectorBool() { bools = new vector<bool>(); }
	~vectorBool() { delete bools; }
};

class TruthTableElem
{
public:
	vector<bool> *in;
	vector<bool> *out;
	
	TruthTableElem() { in = new vector<bool>(); out = new vector<bool>(); }
	TruthTableElem(vector<bool> *pin, vector<bool> *pout) { in = pin; out = pout; }
	~TruthTableElem() { delete in; delete out; }
};

class TruthTable
{
public:
	vector<TruthTableElem*> *row;
	TruthTable() { row = new vector<TruthTableElem*>(); }
	~TruthTable() { delete row; }
};

class vectorMetaType{
public:
	vector<MetaType*> *metatypes;
	vectorMetaType() { metatypes = new vector<MetaType*>(); }
	~vectorMetaType() { delete metatypes; }
};

class mapTipo{
public:
	map<string, Tipo*> *tabla_tipos;
	mapTipo() { tabla_tipos = new map<string, Tipo*>(); }
	~mapTipo() { delete tabla_tipos; }
};

class mapBitSet{
public:
	map<string, BitSet*> *tabla_valores;
	mapBitSet() { tabla_valores = new map<string, BitSet*>(); }
	~mapBitSet() { delete tabla_valores; }
};

class mapFuncion
{
public:
	map<string, FuncionValor*> *tabla_funciones;
	mapFuncion() { tabla_funciones = new map<string, FuncionValor*>; }
	~mapFuncion() { delete tabla_funciones; }
};

%}

%{
#include <iostream>
#include "hdl_tree.h"

using namespace std;

%}

%option lang="C++"

/*--------------------------------------------------------------------------------------
					TIPOS
--------------------------------------------------------------------------------------*/

%node Tipo %abstract %typedef = {
	int size;
}

%node Output Tipo
%node Input Tipo
%node Temp Tipo


%node ArrayTipo Tipo = {
	Tipo *tipo;
	int upper;
	int lower;
}

%node SetTipo Tipo = {
	Tipo *tipo;
}

//tipo retorno es INPUT
%node FunctionTipo Tipo = {
	Tipo *tipo;//tipo y tam de retorno
	vectorId *vectorParams;//tam de tipo base
	vectorId *vectorReturn;
}

/*--------------------------------------------------------------------------------------
					METATIPOS
--------------------------------------------------------------------------------------*/

%node MetaType %abstract %typedef = {
	string lexeme;
	Tipo *tipo;
}

%node IdMetaType MetaType

%node ArrayMetaType MetaType = {
	int upper;
	int lower;
}

//%node FunctionMetaType MetaType = {
//}

//--------------------getTipo()--------------------

%operation %virtual Tipo *getTipo(MetaType *this)

getTipo(IdMetaType){
	return tipo;
}

getTipo(ArrayMetaType){
	int tam = (upper - lower) + 1;
	return new ArrayTipo(tam, tipo, upper, lower);
}

/*--------------------------------------------------------------------------------------
					PROGRAMA
--------------------------------------------------------------------------------------*/
%node Program %typedef = {
	string moduleName;
	mapTipo *mapa;
	Statement *functionDeclaration;
	Statement *main;
}

%operation %virtual void Semantica(Program *this)

Semantica(Program){
	if (mapa == NULL){
		cerr << "Tabla de Simbolos NULA!!" << endl << endl;
		exit(1);
	}
		
	if (functionDeclaration != NULL)
		functionDeclaration->validarSemantica();
	cout << "validacion semantica de funciones DONE" << endl;

	if (main == NULL){
		cerr << "Falta funcion main del programa!!" << endl << endl;
		exit(1);
	}
	main->validarSemantica();
	cout << "validacion semantica del main DONE" << endl;
}

%node FuncionValor %typedef = {
	vectorId *input;
	vectorId *output;
	Statement *body;
}

/*--------------------------------------------------------------------------------------
					STATEMENT
--------------------------------------------------------------------------------------*/

%node Statement %abstract %typedef

%node SequenceStmnt Statement = {
	Statement *stmnt1;
	Statement *stmnt2;
}


%node FunctionStmntTT Statement = {
	string Id;
	vectorId *params;
	vectorId *returns;
	TruthTable *ttable;
}

%node FunctionStmntST Statement = {
	string Id;
	vectorId *params;
	vectorId *returns;
	Statement *stmnts;
}

%node AssignStmnt Statement = {
	Expr *lvalue;
	Expr *rvalue;
}


%node WhenStmnt Statement = {
	Expr *cond;
	Statement *true_block;
	Statement *false_block;
}

//--------------------validarSemantica()--------------------

%operation %virtual void validarSemantica(Statement *this)

validarSemantica(SequenceStmnt){
//cout << "Entrando a validacion SEQ" << endl;
	if (stmnt1 != NULL)
		stmnt1->validarSemantica();
	if (stmnt2 != NULL)
		stmnt2->validarSemantica();
//cout << "Saliendo de validacion SEQ" << endl;
}

validarSemantica(FunctionStmntST){
//cout << "Entrando a validacion de FuncionST" << endl;
	stmnts->validarSemantica();
//cout << "Saliendo de validacion de FuncionST" << endl;
}

validarSemantica(FunctionStmntTT){
//cout << "Entrando a validacion de FuncionTT" << endl;

	long inCount = ttable->row->at(0)->in->size();
	long paramCount = params->ids->size();
	if (inCount != paramCount){
		cerr << "Cantidad de variables de entrada incorrecta!! tabla:" << inCount << " params:" << paramCount << endl << endl;
		exit(1);
	}
	long outCount = ttable->row->at(0)->out->size();
	long retCount = returns->ids->size();
	if (outCount != retCount){
		cerr << "Cantidad de variables de salida incorrecta!! tabla:" << outCount << " returns:" << retCount << endl << endl;
		exit(1);
	}
	long s = params->ids->size();
	long filas = s*s;
	if (ttable->row->size() != filas){
		cerr << "Cantidad de filas incorrecta en thruth_table!! filas: " << filas << endl << endl;
		exit(1);
	}
//cout << "Saliendo de validacion de FuncionTT" << endl;
}

validarSemantica(AssignStmnt){
//cout << "Entrando a validacion ASSIGN" << endl;
	Tipo *tlvalue = lvalue->validarSemantico();
//cout << "lvalue Semantica DONE" << endl;
	Tipo *trvalue = rvalue->validarSemantico(); 
//cout << "rvalue Semantica DONE" << endl;

	if (tlvalue->size != trvalue->size){
		cerr << "Size de conjuntos distinto!! lval: " << tlvalue->size << " rvalue: " << trvalue->size << endl << endl;
		exit(1);
	}
	if (tlvalue->getKind() == Input_kind){
		cerr << "Conjuntos del lado izquierdo de la asignacion deben ser de tipo Output!!" << endl << endl;
		exit(1);
	}
	if (trvalue->getKind() == Output_kind){
		cerr << "Conjuntos del lado derecho de la asignacion deben ser de tipo Input!!" << endl << endl;
		exit(1);
	}
//cout << "Saliendo de validacion ASSIGN" << endl;
}

validarSemantica(WhenStmnt){
	Tipo *tcond = cond->validarSemantico();

	true_block->validarSemantica();

	if (false_block != NULL)
		false_block->validarSemantica();
}

//--------------------interpret()--------------------

/*%operation %virtual void interpret(Statement *this)

interpret(StatementSeq) {
	if (stmnt1 != NULL)
		stmnt1->interpret();
	if (stmnt2 != NULL)
		stmnt2->interpret();
}

interpret(AssignStmnt){
	//nada
}

interpret(WhenStmnt){
	int val = cond->eval();
	if (val > 0){
		if (stmnt1 != NULL)
			stmnt1->interpret();
	} else {
		if (stmnt2 != NULL)
			stmnt2->interpret();
	}
}

interpret(TruthTableStmnt){
	
}*/

/*--------------------------------------------------------------------------------------
					Expresiones
--------------------------------------------------------------------------------------*/
%node Expr %abstract %typedef

%node BinaryExpr Expr %abstract = {
	Expr *exprLeft;
	Expr *exprRight;
}

%node GreaterExpr BinaryExpr
%node GreaterEqualExpr BinaryExpr
%node LessExpr BinaryExpr
%node LessEqualExpr BinaryExpr
%node EqualExpr BinaryExpr
%node NotEqualExpr BinaryExpr

%node ShiftLeftExpr BinaryExpr
%node ShiftRightExpr BinaryExpr

%node AndExpr BinaryExpr
%node OrExpr BinaryExpr
%node XorExpr BinaryExpr
%node XnorExpr BinaryExpr

%node AddExpr BinaryExpr
%node SubExpr BinaryExpr
%node MultExpr BinaryExpr
%node DivExpr BinaryExpr
%node ModExpr BinaryExpr

%node UnaryExpr Expr %abstract = {
	Expr *expr;
}

%node NegateExpr UnaryExpr
%node NotExpr UnaryExpr

%node NumExpr Expr = {
	long value;
	int size;
	BitSet *bs;
}


%node ReferenceAccess Expr %abstract %typedef = {
	string lexeme;
}


%node IdExpr ReferenceAccess

%node ArrayIndexExpr IdExpr = {
	int index;
}

%node ArraySubSetExpr ArrayIndexExpr = {
	int index2;
}

%node SetExpr Expr = {
	vectorExpr *vector;
}

%node FuncCallExpr ReferenceAccess = {
	vectorExpr *vector;
}

//--------------------validarSemantico()--------------------
%operation %virtual Tipo *validarSemantico(Expr *this)

validarSemantico(GreaterExpr),
validarSemantico(GreaterEqualExpr),
validarSemantico(LessExpr),
validarSemantico(LessEqualExpr),
validarSemantico(EqualExpr),
validarSemantico(NotEqualExpr),

validarSemantico(ShiftLeftExpr),
validarSemantico(ShiftRightExpr),

validarSemantico(AndExpr),
validarSemantico(OrExpr),
validarSemantico(XorExpr),
validarSemantico(XnorExpr),

validarSemantico(AddExpr),
validarSemantico(SubExpr),
validarSemantico(MultExpr),
validarSemantico(DivExpr),
validarSemantico(ModExpr) {
	Tipo *t1 = exprLeft->validarSemantico();
	Tipo *t2 = exprRight->validarSemantico();
	
	if (t1->size != t2->size){
		cerr << "Sizes incompatibles en la expresion!! t1: " << t1->size << " t2: " << t2->size << endl << endl;
		exit(1);
	}
	if ((t1->getKind() != Input_kind) || (t2->getKind() != Input_kind)){
		cerr << "Operando deberia ser de tipo Input!! tk1: " << t1->getKind() << " tk2:" << t2->getKind() << endl << endl;
		exit(1);
	}
	return t1;
}

validarSemantico(NotExpr){
	return expr->validarSemantico();
}

validarSemantico(NegateExpr){
	return expr->validarSemantico();
}

validarSemantico(NumExpr){
	return new Input(size);
}

validarSemantico(FuncCallExpr){
//cout << "Entrando a validacion FUNCCALL" << endl;
	if (TablaTipos->tabla_tipos->count(lexeme) == 0){
		cerr << "No existe la funcion: " << lexeme << endl << endl;
		exit(1);
	}
	Tipo *t = TablaTipos->tabla_tipos->find(lexeme)->second;

	FunctionTipo *tfunc;
	tfunc = reinterpret_cast<FunctionTipo*>(t);

	if (tfunc == NULL){
		cerr << "Error en dynamic_cast!!" << endl << endl;
			exit(1);
	}
	if (tfunc->size != vector->exprs->size()){
		cerr << "Cantidad de parametros incorrecta!!" << endl << endl;
		exit(1);
	}
	for (int x = 0; x < vector->exprs->size(); x++){
		Tipo *tmp = vector->exprs->at(x)->validarSemantico();
		if (tmp->getKind() == Output_kind){
			cerr << "Parametros deberian ser de tipo Input o Temp!! tmpk: " << tmp->getKind() << endl << endl;
		exit(1);
	}
	}
	
	return tfunc->tipo;
//cout << "Saliendo de validacion FUNCCALL" << endl;
}

validarSemantico(IdExpr){
//cout << "Entrando a validarSemantico de ID" << endl;

	if (TablaTipos->tabla_tipos->count(lexeme) == 0){
		cerr << "No existe la variable: " << lexeme << endl << endl;
		exit(1);
	}

	Tipo *t = TablaTipos->tabla_tipos->find(lexeme)->second;

//cout << "Saliendo de validarSemantico de ID" << endl;	
	if (t->getKind() == ArrayTipo_kind){
		ArrayTipo *arr = reinterpret_cast<ArrayTipo*>(t);

		switch(arr->tipo->getKind()){
			case Output_kind:	return new Output(arr->size);
			case Input_kind:	return new Input(arr->size);
			default:		return new Temp(arr->size);
		}
	} else
		return t;
}

validarSemantico(ArrayIndexExpr)
{
	if (TablaTipos->tabla_tipos->count(lexeme) == 0){
		cerr << "No existe la variable: " << lexeme << endl << endl;
		exit(1);
	}
	Tipo *t = TablaTipos->tabla_tipos->find(lexeme)->second;

	if (t->getKind() != ArrayTipo_kind){
		cerr << "Tipo incorrecto de arreglo!!" << endl << endl;
		exit(1);
	}
	ArrayTipo *arr = reinterpret_cast<ArrayTipo*>(t);

	if (index > arr->upper){
		cerr << "Indice por encima del limite superior de arreglo!!" << endl << endl;
		exit(1);
	}
	if (index < arr->lower){
		cerr << "Indice por debajo del limite inferior de arreglo!!" << endl << endl;
		exit(1);
	}
	return arr->tipo;
}

validarSemantico(ArraySubSetExpr)
{
	if (TablaTipos->tabla_tipos->count(lexeme) == 0){
		cerr << "No existe la variable: " << lexeme << endl << endl;
		exit(1);
	}
	Tipo *t = TablaTipos->tabla_tipos->find(lexeme)->second;

	if (t->getKind() != ArrayTipo_kind){
		cerr << "Tipo incorrecto de arreglo!!" << endl << endl;
		exit(1);
	}
	ArrayTipo *arr = reinterpret_cast<ArrayTipo*>(t);

	if ((index - index2) > arr->size){
		cerr << "ArraySubSet mas grande que el arreglo!!" << endl << endl;
		exit(1);
	}
	if (index > arr->upper){
		cerr << "Indice upper por encima del limite superior soportado!!" << endl << endl;
		exit(1);
	}
	if (index2 < arr->lower){
		cerr << "Indice lower por debajo del limite inferior soportado!!" << endl << endl;
		exit(1);
	}
	switch(arr->tipo->getKind()){
		case Output_kind:	return new Output((index-index2)+1);
		case Input_kind:	return new Input((index-index2)+1);
		default:		return new Temp((index-index2)+1);
	}
}

validarSemantico(SetExpr){
	int size = 0;
	for (int x = 0; x < vector->exprs->size(); x++){
		Tipo *t = vector->exprs->at(x)->validarSemantico();
		size += t->size;
		if (t->getKind() == Input_kind){
			cerr << "Tipos de Conjunto deberia ser Output o Temp!!! tk: " << t->getKind() << endl << endl;
			exit(1);
		}
	}
	return  new Output(size);
}


//--------------------eval()--------------------

%operation %virtual BitSet* eval(Expr *this)

eval(GreaterExpr),
eval(GreaterEqualExpr),
eval(LessExpr),
eval(LessEqualExpr),
eval(EqualExpr),
eval(NotEqualExpr){
	BitSet *v1 = exprLeft->eval();
	BitSet *v2 = exprRight->eval();
	

        switch (getKind()) {
		case GreaterExpr_kind:		return new BitSet(v1->pbitset->size(), (v1->pbitset > v2->pbitset));
		case GreaterEqualExpr_kind:	return new BitSet(v1->pbitset->size(), (v1->pbitset >= v2->pbitset));
		case LessExpr_kind:		return new BitSet(v1->pbitset->size(), (v1->pbitset < v2->pbitset));
		case LessEqualExpr_kind:	return new BitSet(v1->pbitset->size(), (v1->pbitset <= v2->pbitset));
		case EqualExpr_kind:		return new BitSet(v1->pbitset->size(), (v1->pbitset == v2->pbitset));
		case NotEqualExpr_kind:		return new BitSet(v1->pbitset->size(), (v1->pbitset != v2->pbitset));
		default:			cerr << "Error Expresion en evaluacion Binaria!!" << endl << endl; exit(1);
	}
}

eval(ShiftLeftExpr),
eval(ShiftRightExpr){
	BitSet *v1 = exprLeft->eval();
	BitSet *v2 = exprRight->eval();
	

/*        switch (getKind()) {
//		case ShiftLeftExpr_kind:	return new BitSet(v->pbitset->size() ,(v1->pbitset << v2->pbitset->to_ulong()).to_ulong());
//		case ShiftRightExpr_kind:	return (v1->pbitset >> v2->pbitset);
		default:			cerr << "Error Expresion en evaluacion Binaria!!" << endl << endl; exit(1);
	}*/
	return NULL;
}

eval(AndExpr),
eval(OrExpr),
eval(XorExpr),
eval(XnorExpr){
	BitSet *v1 = exprLeft->eval();
	BitSet *v2 = exprRight->eval();
	

/*        switch (getKind()) {
		case AndExpr_kind:		return new BitSet(v1->pbitset->size(), (v1->pbitset & v2->pbitset));
		case OrExpr_kind:		return new BitSet(v1->pbitset->size(), (v1->pbitset | v2->pbitset));
		case XorExpr_kind:		return new BitSet(v1->pbitset->size(), (v1->pbitset ^ v2->pbitset));
		case XnorExpr_kind:		return new BitSet(v1->pbitset->size(), !(v1->pbitset ^ v2->pbitset));
		default:			cerr << "Error Expresion en evaluacion Binaria!!" << endl << endl; exit(1);
	}*/
	return NULL;
}

eval(AddExpr),
eval(SubExpr),
eval(MultExpr),
eval(DivExpr),
eval(ModExpr) {
	BitSet *v1 = exprLeft->eval();
	BitSet *v2 = exprRight->eval();
	

/*        switch (getKind()) {

		case AddExpr_kind:		return new BitSet(v1->pbitset->size(), (v1->pbitset->to_ulong() + v2->pbitset->to_ulong()));
		case SubExpr_kind:		return new BitSet(v1->pbitset->size(), (v1->pbitset->to_ulong() - v2->pbitset->to_ulong()));
		case MultExpr_kind:		return new BitSet(v1->pbitset->size(), (v1->pbitset->to_ulong() * v2->pbitset->to_ulong()));
		case DivExpr_kind:		return new BitSet(v1->pbitset->size(), (v1->pbitset->to_ulong() / v2->pbitset->to_ulong()));
		case ModExpr_kind:		return new BitSet(v1->pbitset->size(), (v1->pbitset->to_ulong() % v2->pbitset->to_ulong()));
		
		default:			cerr << "Error Expresion en evaluacion Binaria!!" << endl << endl; exit(1);
        }*/
	return NULL;
}

eval(NegateExpr),
eval(NotExpr) {
	BitSet *v = expr->eval();
	
	switch (getKind()) {
		case NegateExpr_kind:		return new BitSet(v->pbitset->size(),(new BitSet(v->pbitset->size(), 0))->pbitset-(v->pbitset));
		case NotExpr_kind:		return new BitSet(v->pbitset->size(),!(v->pbitset));
	}
}

eval(NumExpr) {
	return bs;
}

eval(IdExpr) {
	return NULL; //tmp
}

eval(FuncCallExpr) {
	return NULL; //tmp
}

eval(ArrayIndexExpr) {
	return NULL; //tmp
}

eval(ArraySubSetExpr) {
	return NULL; //tmp
}

eval(SetExpr) {
	return NULL; //tmp
}
