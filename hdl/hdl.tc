%decls %{
#include <string>
#include <vector>
#include <map>

using namespace std;

class vectorExpr;
class vectorId;

class vectorBool;
class TruthTableElem;
class TruthTable;

class vectorMetaType;
class VariableDeclarationList;
%}

%decls %end %{

class vectorExpr
{
public:
	vector<Expr*> *exprs;
	
	vectorExpr(){ exprs = new vector<Expr*>(); }
	~vectorExpr() { delete exprs; }
};

class vectorId
{
public:
	vector<string> *ids;
	
	vectorId() { ids = new vector<string>(); }
	~vectorId() { delete ids; }
};

class vectorBool
{
public:
	vector<bool> *bools;
	vectorBool() { bools = new vector<bool>(); }
	~vectorBool() { delete bools; }
};

class TruthTableElem
{
public:
	vectorBool *in;
	vectorBool *out;
	
	TruthTableElem() { in = new vectorBool(); out = new vectorBool(); }
	TruthTableElem(vectorBool *pin, vectorBool *pout) { in = pin; out = pout; }
	~TruthTableElem() { delete in; delete out; }
};

class TruthTable
{
public:
	vector<TruthTableElem*> *row;
	TruthTable() { row = new vector<TruthTableElem*>(); }
	~TruthTable() { delete row; }
};

class vectorMetaType{
public:
	vector<MetaType*> *metatypes;
	vectorMetaType() { metatypes = new vector<MetaType*>(); }
	~vectorMetaType() { delete metatypes; }
};

class VariableDeclarationList{
public:
	map<string, MetaType*> *tabla;
	VariableDeclarationList() { tabla = new map<string, MetaType*>(); }
	~VariableDeclarationList() { delete tabla; }
};

%}

%{
#include <iostream>
#include "hdl_tree.h"

using namespace std;

%}

%option lang="C++"

/*--------------------------------------------------------------------------------------
					TIPOS
--------------------------------------------------------------------------------------*/

%node Tipo %abstract %typedef

%node Output Tipo
%node Input Tipo
%node Temp Tipo

%node ArrayTipo Tipo = {
	Tipo *tipo;
	int upper;
	int lower;
}

%node MetaType %abstract %typedef = {
	string lexeme;
	Tipo *tipo;
}

%node IdMetaType MetaType

%node ArrayMetaType MetaType = {
	int upper;
	int lower;
}

/*--------------------------------------------------------------------------------------
					PROGRAMA
--------------------------------------------------------------------------------------*/
%node Program %typedef = {
	string moduleName;
	VariableDeclarationList *variableDeclarationList;
	Sentence *functionDeclaration;
	Statement *main;
}


/*--------------------------------------------------------------------------------------
					SENTENCIAS
--------------------------------------------------------------------------------------*/

%node Statement %abstract %typedef

%node StatementSeq Statement = {
	Statement *stmnt1;
	Statement *stmnt2;
}

%node AssignStmnt Statement = {
	Expr *lvalue;
	Expr *rvalue;
}


%node WhenStmnt Statement = {
	Expr *cond;
	Statement *stmnt1;
	Statement *stmnt2;
}

%node TruthTableStmnt Statement = {
	TruthTable *table;
}

%node Sentence %abstract %typedef

%node SequenceSntnce Sentence = {
	Sentence *sntnce1;
	Sentence *sntnce2;
}

%node FunctionSntnce Sentence = {
	string Id;
	vectorId *params;
	vectorId *returns;
	Statement *body;
}

//--------------------interpret()--------------------

%operation %virtual void interpret(Statement *this)

interpret(StatementSeq) {
	if (stmnt1 != NULL)
		stmnt1->interpret();
	if (stmnt2 != NULL)
		stmnt2->interpret();
}

interpret(AssignStmnt){
	//nada
}

interpret(WhenStmnt){
	int val = cond->eval();
	if (val > 0){
		if (stmnt1 != NULL)
			stmnt1->interpret();
	} else {
		if (stmnt2 != NULL)
			stmnt2->interpret();
	}
}

interpret(TruthTableStmnt){
	
}

/*--------------------------------------------------------------------------------------
					Expresiones
--------------------------------------------------------------------------------------*/
%node Expr %abstract %typedef

%node BinaryExpr Expr %abstract = {
	Expr *exprLeft;
	Expr *exprRight;
}

%node GreaterExpr BinaryExpr
%node GreaterEqualExpr BinaryExpr
%node LessExpr BinaryExpr
%node LessEqualExpr BinaryExpr
%node EqualExpr BinaryExpr
%node NotEqualExpr BinaryExpr

%node ShiftLeftExpr BinaryExpr
%node ShiftRightExpr BinaryExpr

%node AndExpr BinaryExpr
%node OrExpr BinaryExpr
%node XorExpr BinaryExpr
%node XnorExpr BinaryExpr

%node AddExpr BinaryExpr
%node SubExpr BinaryExpr
%node MultExpr BinaryExpr
%node DivExpr BinaryExpr
%node ModExpr BinaryExpr

%node UnaryExpr Expr %abstract = {
	Expr *expr;
}

%node NegateExpr UnaryExpr
%node NotExpr UnaryExpr

%node NumExpr Expr = {
	int value;
}

%node BinNumExpr NumExpr
%node OctNumExpr NumExpr
%node HexNumExpr NumExpr
%node DecNumExpr NumExpr

%node FuncCallExpr Expr = {
	string function_name;
	vectorExpr *expressions;
}

%node ReferenceAccess Expr %abstract %typedef = {
	string id;
}

%node IdExpr ReferenceAccess

%node ArrayIndexExpr IdExpr = {
	int index;
}

%node ArraySubSetExpr ArrayIndexExpr = {
	int index2;
}

%node SetExpr Expr = {
	vectorExpr *ids;
}

//--------------------eval()--------------------

%operation %virtual long eval(Expr *this)

eval(GreaterExpr),
eval(GreaterEqualExpr),
eval(LessExpr),
eval(LessEqualExpr),
eval(EqualExpr),
eval(NotEqualExpr),

eval(ShiftLeftExpr),
eval(ShiftRightExpr),

eval(AndExpr),
eval(OrExpr),
eval(XorExpr),
eval(XnorExpr),

eval(AddExpr),
eval(SubExpr),
eval(MultExpr),
eval(DivExpr),
eval(ModExpr) {
	long v1 = exprLeft->eval();
	long v2 = exprRight->eval();
	
        switch (getKind()) {
		case GreaterExpr_kind:		return v1 > v2;
		case GreaterEqualExpr_kind:	return v1 >= v2;
		case LessExpr_kind:		return v1 < v2;
		case LessEqualExpr_kind:	return v1 <= v2;
		case EqualExpr_kind:		return v1 == v2;
		case NotEqualExpr_kind:		return v1 != v2;

		case ShiftLeftExpr_kind:	return v1 << v2;
		case ShiftRightExpr_kind:	return v1 >> v2;

		case AndExpr_kind:		return v1 & v2;
		case OrExpr_kind:		return v1 | v2;
		case XorExpr_kind:		return v1 ^ v2;
		case XnorExpr_kind:		return !(v1 ^ v2);

		case AddExpr_kind:		return v1 + v2;
		case SubExpr_kind:		return v1 - v2;
		case MultExpr_kind:		return v1 * v2;
		case DivExpr_kind:		return v1 / v2;
		case ModExpr_kind:		return v1 % v2;
		
		default:			break;
        }
	return 0;
}

eval(NegateExpr),
eval(NotExpr) {
	long v = expr->eval();
	
	switch (getKind()) {
		case NegateExpr_kind:		return -v;
		case NotExpr_kind:		return !v;
	}
}

eval(NumExpr) {
	return value;
}

eval(IdExpr) {
	return 1;//tmp
}

eval(FuncCallExpr) {
	/*
	cout << "funcCall exprs: " << endl;
	for(int x = 0; x < expressions->vector_exprs->size(); x++)
		cout << expressions->vector_exprs->at(x)->eval() << endl;
	*/
	return 1;//tmp
}

eval(ArrayIndexExpr) {
//	cout << "refIndex: " << index << endl;
	return 1;//tmp
}

eval(ArraySubSetExpr) {
	return 1;//tmp
}

eval(SetExpr) {
	return 1;//tmp
}
